{
	"Author": {
		"prefix": "auth",
		"body": [
		  "/**",
		  " *    author:  MrRD",
		  " *    created: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND      ",
		  "**/",
		  ""
		],
		"description": "Author"
	  }
	,
	"My Coding Template": {
		"prefix": "temp",
		"body": [
			"/**",
			" *    author:  MrRD",
			" *    created: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND      ",
			"**/",
			"",
			"#include<bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp> // Common file",
			"#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update",
			"#define lli long long int",
			"#define pb push_back",
			"#define in insert",
			"#define mp make_pair",
			"#define pii pair<int,int>",
			"#define piil pair<lli,lli>",
			"#define ff first",
			"#define ss second",
			"#define sz(x) (int)(x.size())",
			"#define all(x) x.begin(),x.end()",
			"#define clr(x) memset(x,0,sizeof(x))",
			"#define fo(i,n) for(int i=0;i<n;i++)",
			"#define fo1(i,n) for(int i=1;i<=n;i++)",
			"#define FOR(i,a,b) for(int i=a;i<=b;i++)",
			"#define FORN(i,a,b) for(int i=a;i>=b;i--)",
			"#define b_pop(x)  __builtin_popcount(x)",
			"#define b_popll(x) __builtin_popcountll(x)//number of set bits",
			"#define b_clz(x) __builtin_clz(x)//leading zeroes",
			"#define b_ctz(x) __builtin_ctz(x) //trailing zeroes",
			"#define b_par(x) __builtin_parity(x) //parity",
			"#define fast ios_base::sync_with_stdio(0);cin.tie(0);cout.tie()",
			"#define trav(a,x) for (auto& a: x)",
			"#define deb(x) cout<<#x<<\"=\"<<x<<\"\\n\"//debugging",
			"#define OJ \\",
			"    freopen(\"input.txt\", \"r\", stdin); \\",
			"    freopen(\"output.txt\", \"w\", stdout);",
			"",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
			"typedef tree<",
			"int,",
			"null_type,",
			"less<int>,",
			"rb_tree_tag,",
			"tree_order_statistics_node_update>",
			"ordered_set;",
			"const int MX=(int)(2e5)+5;",
			"int darr[4][2]={{1,0},{-1,0},{0,1},{0,-1}};",
			"int arr[MX];",
			"vector<int>graph[MX];",
			"",
			"// Utility functions",
			"void setPrec(int n) { cout << fixed << setprecision(n); }",
			"template<typename A>",
			"A Max(A a,A b){",
			"    return max(a,b);",
			"}",
			"template<typename A,typename... Args>",
			"A Max(A a,A b,Args... args){",
			"    return Max(Max(a,b),args...);",
			"}",
			"template<typename A>",
			"A Min(A a,A b){",
			"    return min(a,b);",
			"}",
			"template<typename A,typename... Args>",
			"A Min(A a,A b,Args... args){",
			"    return Min(Min(a,b),args...);",
			"}",
			"template<typename A,typename... Args>",
			"void amin(A& a,Args... args){",
			"    a=Min(a,args...);",
			"}",
			"template<typename A,typename... Args>",
			"void amax(A& a,Args... args){",
			"    a=Max(a,args...);",
			"}",
			"void dbg_out() { cout << endl; }",
			"template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cout << H<<\" \"; dbg_out(T...); }",
			"",
			"//GCD portion (without Euclids)",
			"",
			"template<typename T>",
			"",
			"T GCD(T a,T b){",
			"    if(b==0)return a;",
			"    else return GCD(b,a%b);",
			"}",
			"",
			"",
			"//adding a graph template",
			"void ipgraph(int n,int m){",
			"",
			"    int u,v;",
			"    fo1(i,m){",
			"        cin>>u>>v;",
			"        graph[u].pb(v);",
			"        graph[v].pb(u);",
			"    }",
			"}",
			"",
			"",
			"",
			"",
			"",
			"//problem solver",
			"void solve(){",
			"    ",
			"   ",
			"}",
			"",
			"",
			"int main(){ ",
			"   ",
			"    // OJ;",
			"",
			"    fast;",
			"",
			"    int t;",
			"    // cin>>t;",
			"    t=1;",
			"",
			"    while(t--){",
			"        solve();",
			"",
			"    }",
			"    ",
			"    return 0;",
			"}",
			"",
			"",
			"",
			""
		],
		"description": "My Coding Template"
	},
	"Binary Indexed Tree": {
		"prefix": "bit",
		"body": [
			"void update(int ind,int val,int n){",
			"",
			"    while(ind<=n){",
			"",
			"            BIT[ind]+=val;",
			"            ind+=(ind&(-ind));",
			"    }",
			"",
			"",
			"",
			"}",
			"int query(int ind){",
			"",
			"    int ans=0;",
			"    while(ind>=1){",
			"",
			"        ans+=BIT[ind];",
			"        ind-=(ind&(-ind));",
			"    }",
			"    return ans;",
			"}",
			""
		],
		"description": "Binary Indexed Tree"
	},
	"2D Binary Indexed Tree": {
		"prefix": "bit2d",
		"body": [
			"void update(int x,int y,int val,int n){",
			"",
			"    while(x<=n){",
			"",
			"        for(int i=y;i<=n;i+=(i&(-i))){",
			"            BIT[x][i]+=val;",
			"        }",
			"        x+=(x&(-x));",
			"    }",
			"}",
			"int query(int x,int y){",
			"    int ans=0;",
			"    while(x>0){",
			"        for(int i=y;i>0;i-=(i&(-i))){",
			"            ans+=BIT[x][i];",
			"        }",
			"        x-=(x&(-x));",
			"    }",
			"    return ans;",
			"}",
			"",
			""
		],
		"description": "2D Binary Indexed Tree"
	},
	"Binary Exponentiation": {
		"prefix": "binexp",
		"body": [
			"template<typename T,typename Tp>",
			"lli binexp(T no,Tp pw){",
			"",
			"    lli res=1;",
			"    lli pw2=pw;",
			"    lli val=no;",
			"    lli temp=1;",
			"    while(pw2>0){",
			"",
			"        if(temp& pw2){",
			"            res*=val;",
			"            pw2^=temp;",
			"        }",
			"        val*=val;",
			"        temp<<=1;",
			"        ",
			"",
			"        ",
			"    }",
			"    return res;",
			"",
			"}"
		],
		"description": "Binary Exponentiation"
	},
	"Trie ": {
		"prefix": "trie",
		"body": [
		  "struct Trie{",
		  "",
		  "        Trie *one,*zero;",
		  "        ",
		  "        ",
		  "        void insert(int val,int ind);",
		  "        int maxquery(int val,int ind);",
		  "        int minquery(int val,int ind);",
		  "",
		  "        Trie(){",
		  "            this->one=NULL;",
		  "            this->zero=NULL;",
		  "        }",
		  "",
		  "            ",
		  "       ",
		  "};",
		  "",
		  "void Trie::insert(int val,int ind){",
		  "",
		  "        if(ind<0)return;",
		  "        int posval=val&(1<<ind);",
		  "        if(posval){",
		  "            if(this->one== NULL){",
		  "                one=new Trie();",
		  "            }",
		  "            one->insert(val,ind-1);",
		  "            ",
		  "        }",
		  "        else{",
		  "            if(this->zero==NULL){",
		  "                zero=new Trie();",
		  "            }",
		  "            zero->insert(val,ind-1);",
		  "            ",
		  "        }",
		  "}",
		  "",
		  "int Trie::maxquery(int val,int ind){",
		  "",
		  "",
		  "        if(ind<0)return  0;",
		  "",
		  "        int posval=val&(1<<ind);",
		  "        int finval=1<<ind;",
		  "        Trie *next;",
		  "        if(posval){",
		  "            if(this->zero==NULL){",
		  "                next=one;",
		  "                finval=0;",
		  "                }",
		  "            else next=zero;",
		  "          ",
		  "        }",
		  "        else{",
		  "             if(this->one==NULL){",
		  "                next=zero;",
		  "                finval=0;",
		  "             }",
		  "             else {",
		  "                next=one;",
		  "               ",
		  "                }",
		  "            ",
		  "        }",
		  "        return  finval+next->maxquery(val,ind-1);",
		  "}",
		  "",
		  "int Trie::minquery(int val,int ind){",
		  "",
		  "",
		  "        if(ind<0)return  0;",
		  "",
		  "        int posval=val&(1<<ind);",
		  "        int finval=0;",
		  "        Trie *next;",
		  "        if(posval){",
		  "            if(this->one==NULL){",
		  "                next=zero;",
		  "                finval=1<<ind;",
		  "            }",
		  "            else next=one;",
		  "        }",
		  "        else{",
		  "             if(this->zero==NULL){",
		  "                next=one;",
		  "                finval=1<<ind;",
		  "             }",
		  "             else next=zero;",
		  "        }",
		  "        ",
		  "        return  finval+next->minquery(val,ind-1);",
		  "}"
		],
		"description": ""
	  },
      "Prefix Function": {
        "prefix": "preffn",
        "body": [
          "vector<int> prefix_function(string s) {",
          "    int n = (int)s.length();",
          "    vector<int> pi(n);",
          "    for (int i = 1; i < n; i++) {",
          "        int j = pi[i-1];",
          "        while (j > 0 && s[i] != s[j])",
          "            j = pi[j-1];",
          "        if (s[i] == s[j])",
          "            j++;",
          "        pi[i] = j;",
          "    }",
          "    return pi;",
          "}",
          ""
        ],
        "description": "Prefix Function"
      }
	
}